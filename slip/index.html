<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>red roof</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#bfefff;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #overlay{
    position: absolute;left:12px;top:12px;color:#021b2b;
    background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.82));
    padding:12px;border-radius:8px;font-size:13px;backdrop-filter: blur(4px);
    max-width:480px;box-shadow:0 8px 28px rgba(0,0,0,0.12);
    z-index: 10;
  }
  
  /* Hides the slider rows while keeping the data/IDs available for the script */
  .param, .model-controls { display: none !important; }

  .small{font-size:12px;color:#052a3a;}
  #canvas{position:fixed;left:0;top:0;width:100%;height:100%;display:block;z-index:0}
  footer{position: absolute;right:12px;bottom:12px;color:#073b5a;font-size:12px}
  .big{font-weight:700;color:#032a45;margin-bottom:4px;}
  .status { margin-top:6px; font-size:12px; color:#052a45; line-height: 1.4; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="overlay">
  <div class="big">i cant help but notice cobwalt is flying</div>
  
  <div class="param"><input id="boostRange" type="range" value="60"></div>
  <div class="param"><input id="dodgeRange" type="range" value="100"></div>
  <div class="param"><input id="gravRange" type="range" value="9.81"></div>
  <div class="param"><input id="tiltAccelRange" type="range" value="0.7"></div>
  <div class="param"><input id="pitchSpeedRange" type="range" value="1.4"></div>
  <div class="param"><input id="rollSpeedRange" type="range" value="1.4"></div>
  <div class="param"><input id="yawSpeedRange" type="range" value="0.0022"></div>

  <div class="loadBig">
    <b>Speed:</b> <span id="speed">0</span> m/s • <b>Height:</b> <span id="height">0</span> m<br>
    <b>Destabilizers:</b> <span id="destText">OFF</span><br>
    <b>Pos:</b> <span id="posX">0</span>, <span id="posY">0</span>, <span id="posZ">0</span><br>
    <b>Facing:</b> <span id="facingDir">0, 0, 1</span>
  </div>
</div>
  <div style="margin-top:8px;display:none;">
    <div style="font-weight:600;color:#032a45;margin-bottom:6px">model control</div>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Yaw</label>
  <input id="rotYaw" type="range" min="-180" max="180" value="0">
        <span id="rotYawVal" class="small">0°</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Pitch</label>
  <input id="rotPitch" type="range" min="-180" max="180" value="-90">
        <span id="rotPitchVal" class="small">0°</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Roll</label>
  <input id="rotRoll" type="range" min="-180" max="180" value="-90">
        <span id="rotRollVal" class="small">0°</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Scale</label>
  <input id="scaleSlider" type="range" min="0.01" max="5" step="0.01" value="0.01">
  <span id="scaleVal" class="small">0.01x</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">X</label>
  <input id="modelPosX" type="range" min="-100" max="100" step="0.01" value="-0.6">
  <span id="modelPosXVal" class="small">-0.60</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Y</label>
  <input id="modelPosY" type="range" min="-20" max="20" step="0.1" value="-3.25">
  <span id="modelPosYVal" class="small">-3.25</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <label class="small">Z</label>
  <input id="modelPosZ" type="range" min="-50" max="20" step="0.1" value="-15">
  <span id="modelPosZVal" class="small">-15.00</span>
      </div>
    </div>
  </div>
</div>
<div id="loadStatus" style="position: absolute; left:12px; bottom:12px; background: rgba(255,255,255,0.9); padding:8px; border-radius:6px; font-size:12px; color:#022;">Model: checking...</div >
<div id="loadBig" style="position:absolute;left:50%;top:40%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);color:#fff;padding:12px 18px;border-radius:10px;font-size:15px;display:none;z-index:9999">
  <div id="loadBigText">Loading...</div>
  <div style="margin-top:8px;text-align:center"><button id="loadBtn" style="margin-top:6px;padding:6px 12px;border-radius:6px;border:none;cursor:pointer">Load external model</button></div>
</div>
<footer> </footer>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js"
    }
  }
</script>
<script>
// ============================================================================
// ERROR HANDLING
// ============================================================================
// Global error reporting for debugging — show errors in the on-page status
window.addEventListener('error', function(e){
  try{ console.error('Window error:', e.message, e.filename + ':' + e.lineno); }catch(_){ }
  const el = document.getElementById('loadStatus'); if(el) el.textContent = 'ERROR: ' + (e.message || e.error || 'unknown');
});
window.addEventListener('unhandledrejection', function(e){
  try{ console.error('UnhandledRejection:', e.reason); }catch(_){ }
  const el = document.getElementById('loadStatus'); if(el) el.textContent = 'ERROR: ' + (e.reason && e.reason.message ? e.reason.message : String(e.reason));
});
console.log('script start');
const statusInit = document.getElementById('loadStatus'); if(statusInit) statusInit.textContent = 'Model: script started';
let angularVelocityZ = 0; // Tracks the "spin" momentum for dodges

// ============================================================================
// PHYSICS & CONTROL CONSTANTS
// ============================================================================
// All tunable parameters for flight physics, control responsiveness, and stabilization
const PHYS = {
  boostAccel: 100.0,           // Right-click boost acceleration (forward)
  dodgeImpulse: 40.0,          // Q/E dodge impulse magnitude
  gravity: 14,                 // Downward acceleration (world units/sec²)
  upThrust: 36.0,              // Space key upward thrust
  horizAccel: 42.0,            // WASD horizontal acceleration (when destabilizers OFF)
  airDrag: 10.0,               // Air resistance damping factor
  maxSpeed: 200.0,             // Speed limiter cap
  dodgeCooldown: 0.25,         // Cooldown between dodge impulses (seconds)
  rollSpeed: Math.PI*1.4,          // Roll rotation speed when tilting (destab mode) (rad/sec)
  pitchSpeed: Math.PI*1.4,         // Pitch rotation speed when tilting (destab mode) (rad/sec)
  mouseSens: 0.0022,           // Pointer lock mouse sensitivity
  groundAlignDist: 1.2,        // Distance from ground to trigger alignment (units)
  groundAlignSlerp: 0.1,      // Ground alignment slerp factor per frame
  airStabilizeSlerp: 0.000028,    // Auto-stabilize slerp when destabilizers OFF
  destRecoverDuration: 100.0,    // Time to slow recovery after destabilizers release (sec)
  destRecoverSlerp: 0.006,     // Slower slerp during recovery window
  sideAlignSpeed: 0.0006,        // Side-facing alignment slerp factor (when moving)
  sideAlignMinSpeed: 0.5,      // Min speed to trigger side-facing alignment
  camToSparrowSlerp: 1.5,      // Sparrow aims to camera when free-cam active
  shiftGracePeriod: 0.15       // Grace period in seconds before destabilizers turn off
  
};

// Mutable globals for UI slider updates — these get modified by slider inputs
let BOOST_ACCEL = PHYS.boostAccel, DODGE_IMPULSE = PHYS.dodgeImpulse, GRAVITY = PHYS.gravity,
    UP_THRUST = PHYS.upThrust, HORIZONTAL_ACCEL = PHYS.horizAccel, AIR_DRAG = PHYS.airDrag,
    MAX_SPEED = PHYS.maxSpeed, ROLL_SPEED = PHYS.rollSpeed, PITCH_SPEED = PHYS.pitchSpeed,
    MOUSE_SENS = PHYS.mouseSens, GROUND_ALIGN_DIST = PHYS.groundAlignDist,
    GROUND_ALIGN_SLERP = PHYS.groundAlignSlerp, AIR_STABILIZE_SLERP = PHYS.airStabilizeSlerp,
    DESTABILIZER_RECOVER_DURATION = PHYS.destRecoverDuration,
    DESTABILIZER_RECOVER_SLERP = PHYS.destRecoverSlerp, SIDE_ALIGN_SPEED = PHYS.sideAlignSpeed,
    SIDE_ALIGN_MIN_SPEED = PHYS.sideAlignMinSpeed, CAMERA_TO_SPARROW_SLERP = PHYS.camToSparrowSlerp,
    DODGE_COOLDOWN = PHYS.dodgeCooldown, SPARROW_PIVOT_FORWARD = 1.5,
    MAX_TILT_ACCELERATION = 0.7;

// ============================================================================
// THREE.JS SCENE SETUP
// ============================================================================
// Initialize renderer, camera, scene, and lighting
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
console.log('renderer created'); if(statusInit) statusInit.textContent = 'Model: renderer ok';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xbfefff); // light blue sky
// expose scene globally for loaders
window.scene = scene;

// Camera: perspective view with 105° FOV
const camera = new THREE.PerspectiveCamera(105, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0, 6, 14);

// Lighting: directional (sun-like) + ambient
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(12,30,8);
scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

// Ground: large red flat plane at y=0
const floorSize = 10000;
const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize, 1, 1);
const floorMat = new THREE.MeshStandardMaterial({color:0xff3d3d, metalness:0.05, roughness:0.9});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.y = 0;
scene.add(floor);
console.log('floor added'); if(statusInit) statusInit.textContent = 'Model: floor added';

// Subtle grid helper for depth perception
const grid = new THREE.GridHelper(10000, 500, 0xff3d3d, 0xff3d3d);
grid.position.y = 0.003;
scene.add(grid);
console.log('grid added');

// ============================================================================
// SPARROW MODEL (PROCEDURAL + EXTERNAL)
// ============================================================================
// The sparrow consists of a physics pivot group and a visual child group.
// This allows the rotation/physics center to be offset from the visual mesh.

// Visual meshes group (child): body, wings, and arrow indicator
const sparrowVisual = new THREE.Group();
const bodyGeo = new THREE.BoxGeometry(1.6, 0.28, 3.2);
const bodyMat = new THREE.MeshStandardMaterial({color:0x286fb2, metalness:0.35, roughness:0.25});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.set(0,0,0);
sparrowVisual.add(body);

// Wings: thin horizontal planes angled slightly
const wingGeo = new THREE.BoxGeometry(0.2, 0.02, 2.6);
const lw = new THREE.Mesh(wingGeo, bodyMat); lw.position.set(-1.1, -0.02, 0); lw.rotation.x = 0.06; sparrowVisual.add(lw);
const rw = new THREE.Mesh(wingGeo, bodyMat); rw.position.set(1.1, -0.02, 0); rw.rotation.x = -0.06; sparrowVisual.add(rw);

// Forward indicator: yellow cone that shows which direction the sparrow is pointing
const arrowGeo = new THREE.ConeGeometry(0.18, 0.6, 10);
const arrow = new THREE.Mesh(arrowGeo, new THREE.MeshStandardMaterial({color:0xffee77}));
arrow.rotation.x = Math.PI/2; arrow.position.set(0, 0.18, 1.7); sparrowVisual.add(arrow);

// Physics pivot group (parent): all physics calculations apply to this
// The visual meshes are offset forward so the rotation pivot is at the rear
const sparrow = new THREE.Group();
sparrowVisual.position.set(0, 0, SPARROW_PIVOT_FORWARD);
sparrow.add(sparrowVisual);

// Position sparrow in world (will be updated by physics each frame)
sparrow.position.set(0, 6, 0);
scene.add(sparrow);
console.log('sparrow added'); if(statusInit) statusInit.textContent = 'Model: sparrow added';

// ============================================================================
// GIMBAL SPHERE (center of control)
// ============================================================================
// Create the gimbal sphere as an independent world object
const gimbalSphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
const gimbalSphereMat = new THREE.MeshStandardMaterial({color:0x2986cc, emissive:0x2986cc, metalness:0.6, roughness:0.3});
const gimbalSphere = new THREE.Mesh(gimbalSphereGeo, gimbalSphereMat);
gimbalSphere.position.set(0, 6, 0);  // Same height as sparrow initially
scene.add(gimbalSphere);

// Gimbal direction indicator: arrow pointing forward above the sphere
window.gimbalSphere = gimbalSphere;
// Replace your existing window.gimbalOrientation line with this:
window.gimbalOrientation = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0, 'YXZ'));
window.sphereOrientation = new THREE.Quaternion();
window.sparrowFollowOrientation = new THREE.Quaternion().copy(window.gimbalOrientation);

// Store references to procedural meshes so we can hide them when loading external model
window.sparrowParts = { body: body, leftWing: lw, rightWing: rw, arrow: arrow };
// Expose physics pivot globally
window.sparrow = sparrow;

// Ensure procedural sparrow is visible (may have been hidden by previous loads)
sparrow.visible = true;
if(window.sparrowParts){ for(const k in window.sparrowParts){ try{ window.sparrowParts[k].visible = true; }catch(_){} } }
// Clear stale reference from previous model load
window.lastLoadedModel = window.lastLoadedModel || null;

// ============================================================================
// UNIFIED MODEL LOADER
// ============================================================================
// Attempts to load MTL+OBJ from models/ folder; falls back to OBJ-only if MTL 404s
// Uses dynamic imports, with fallback to THREE globals if CDN imports unavailable
async function loadExternalModel(){
  const status = document.getElementById('loadStatus');
  try {
    // Try dynamic import of loaders from CDN first, fall back to THREE globals
    let MTLLoader, OBJLoader;
    try {
      const mod1 = await import('https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/MTLLoader.js');
      const mod2 = await import('https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/OBJLoader.js');
      MTLLoader = mod1.MTLLoader; OBJLoader = mod2.OBJLoader;
    } catch(e) {
      // Fallback: use THREE global loaders if modules not available
      if(typeof THREE !== 'undefined' && THREE.MTLLoader && THREE.OBJLoader) {
        MTLLoader = THREE.MTLLoader; OBJLoader = THREE.OBJLoader;
      } else {
        throw new Error('Loaders not available');
      }
    }
    
    status.textContent = 'Model: loading MTL...';
    const mtl = new MTLLoader(); mtl.setCrossOrigin('');
    
    // Try loading MTL; if it fails, fall back to OBJ-only
    try {
      const materials = await new Promise((res, rej) => mtl.load('models/Sparrow.mtl', res, null, rej));
      materials.preload();
      status.textContent = 'Model: loading OBJ...';
      const obj = await new Promise((res, rej) => {
        const objL = new OBJLoader(); objL.setMaterials(materials);
        objL.load('models/Sparrow.obj', res, null, rej);
      });
      applyModelTransforms(obj);
      status.textContent = 'Model: good :)';
    } catch(e) {
      // MTL load failed: attempt OBJ-only (no materials)
      console.warn('MTL failed, loading OBJ-only:', e.message);
      status.textContent = 'Model: loading OBJ-only...';
      const obj = await new Promise((res, rej) => {
        const objL = new OBJLoader();
        objL.load('models/Sparrow.obj', res, null, rej);
      });
      applyModelTransforms(obj);
      status.textContent = 'Model: loaded (no materials)';
    }
  } catch(e) {
    console.error('Model load failed:', e);
    status.textContent = 'Model: load failed - ' + e.message;
  }
}

// Apply transforms and attach loaded model to scene
function applyModelTransforms(obj){
  // Setup mesh properties for shadows
  obj.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
  
  // Auto-scale model based on bounding box
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(); box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z) || 1;
  const s = 2.5 / maxDim;
  obj.scale.setScalar(s);
  
  // Correct model orientation (assuming OBJ is pointing along different axis)
  obj.rotation.set(0, 0, 0);
  obj.rotateY(-Math.PI/2); obj.rotateZ(Math.PI/2);
  
  // Attach to sparrow physics pivot so it moves with flight
  obj.position.set(0, 0, 0);
  window.sparrow.add(obj);
  
  // Hide procedural meshes so only loaded model shows
  if(window.sparrowParts) { for(const k in window.sparrowParts) { try{ window.sparrowParts[k].visible = false; }catch(_){} } }
  
  // Store reference and initialize UI controls
  window.lastLoadedModel = obj;
  try { if(typeof captureModelBasis === 'function') captureModelBasis(obj); } catch(e){}
  if(typeof applyDefaultPreset === 'function') applyDefaultPreset();
  if(typeof tryInitControlsFromModel === 'function') tryInitControlsFromModel(obj);
  if(typeof safeApplyTransform === 'function') safeApplyTransform();
  console.log('Model loaded:', obj);
}

// Initiate async model load
loadExternalModel().catch(e => console.error('Model loader exception:', e));

// ============================================================================
// PHYSICS STATE
// ============================================================================
// Position, velocity, orientation tracked each frame
let pos = sparrow.position.clone();
let prevPos = sparrow.position.clone();  // For calculating sparrow velocity
let vel = new THREE.Vector3(0,0,0);
let orientation = sparrow.quaternion.clone();
let lastDodgeTime = -999;

// Destabilizer (Shift-hold) mode state and recovery tracking
let destabilizers = false;
const destText = document.getElementById('destText');
let destReleasedAt = null; // Timestamp when destabilizers released (used for slow recovery window)
let windowHasFocus = true;  // Track if the window has focus
let cameraDistance = 7;      // Distance from gimbal to camera
let cameraPitch = 0.5;        // Up/down angle (vertical, relative to gimbal facing)
let cameraYaw = 0;            // Left/right angle (horizontal, relative to gimbal facing)
let isOrbiting = false;       // True when middle-mouse dragging to orbit
let lastOrbitX = 0, lastOrbitY = 0;
let cameraFollowSpeed = 0.005; // Lerp speed for camera follow-with-delay (0=instant, 1=snappy)
let sparrowOrientationLag = 0.05;  // How slowly sparrow catches up to gimbal orientation (lower = more lag, slower reset)
let smoothedCamTarget = new THREE.Vector3();

// Destabilizer input hold tracking — for acceleration effect
let tiltInputHoldTimes = {
  tiltF: 0,  // W hold time (pitch up)
  tiltB: 0,  // S hold time (pitch down)
  tiltL: 0,  // A hold time (roll left)
  tiltR: 0   // D hold time (roll right)
};
// MAX_TILT_ACCELERATION is now a mutable global (see above) for UI slider control
// ============================================================================
// Keyboard input state tracker
const input = {
  boost:false,    // Right-click: continuous forward acceleration
  upThrust:false, // Space: upward acceleration
  moveF: false,   // W: forward (or pitch nose down in destab mode)
  moveB: false,   // S: backward (or pitch nose up in destab mode)
  moveL: false,   // A: left (or roll right in destab mode)
  moveR: false,   // D: right (or roll left in destab mode)
  destHold: false,// Shift: hold to activate destabilizers
  tiltF: false,   // W tilt when destabilizers active
  tiltB: false,   // S tilt when destabilizers active
  tiltL: false,   // A tilt when destabilizers active
  tiltR: false,   // D tilt when destabilizers active
};

// Key down handlers: map keyboard codes to input state updates
const keyDownMap = {
  'KeyW': ()=> { input.moveF = true; if(destabilizers) input.tiltF = true; },
  'KeyS': ()=> { input.moveB = true; if(destabilizers) input.tiltB = true; },
  'KeyD': ()=> { input.moveL = true; if(destabilizers) input.tiltL = true; },
  'KeyA': ()=> { input.moveR = true; if(destabilizers) input.tiltR = true; },
  'ShiftLeft': ()=> { 
    destabilizers = true; 
    destText.textContent = 'ON'; 
    destReleasedAt = null;
    // IMMEDIATE SWAP: If keys are already held, convert them to tilts now
    if(input.moveF) input.tiltF = true;
    if(input.moveB) input.tiltB = true;
    if(input.moveL) input.tiltL = true;
    if(input.moveR) input.tiltR = true;
  },
  'ShiftRight': ()=> { 
    destabilizers = true; 
    destText.textContent = 'ON'; 
    destReleasedAt = null;
    if(input.moveF) input.tiltF = true;
    if(input.moveB) input.tiltB = true;
    if(input.moveL) input.tiltL = true;
    if(input.moveR) input.tiltR = true;
  },
  'Space': ()=> input.upThrust = true,
  'KeyE': ()=> triggerDodge('left'),
  'KeyQ': ()=> triggerDodge('right')
};

// Key up handlers: release input state
const keyUpMap = {
  'KeyW': ()=> { input.moveF = false; input.tiltF = false; },
  'KeyS': ()=> { input.moveB = false; input.tiltB = false; },
  'KeyD': ()=> { input.moveL = false; input.tiltL = false; },
  'KeyA': ()=> { input.moveR = false; input.tiltR = false; },
  'ShiftLeft': ()=> { destabilizers = false; destText.textContent = 'OFF'; resetTiltInputs(); destReleasedAt = performance.now()/1000; },
  'ShiftRight': ()=> { destabilizers = false; destText.textContent = 'OFF'; resetTiltInputs(); destReleasedAt = performance.now()/1000; },
  'Space': ()=> input.upThrust = false
};

// Reset all tilt inputs (used when destabilizers released)
function resetTiltInputs(){
  input.tiltF = input.tiltB = input.tiltL = input.tiltR = false;
}

// Wire up keyboard listeners
window.addEventListener('keydown', (e)=> {
  if(keyDownMap[e.code]) { e.preventDefault(); keyDownMap[e.code](); }
});
window.addEventListener('keyup', (e)=> {
  if(keyUpMap[e.code]) { e.preventDefault(); keyUpMap[e.code](); }
});

// Track window focus state
window.addEventListener('focus', ()=> { windowHasFocus = true; });
window.addEventListener('blur', ()=> { windowHasFocus = false; });

// ============================================================================
// MOUSE & POINTER INPUT
// ============================================================================
// Pointer lock aiming: accumulate mouse delta each frame
let pointerDelta = {x:0,y:0};

// Click canvas to request pointer lock
canvas.addEventListener('click', ()=> {
  if(document.pointerLockElement !== canvas) canvas.requestPointerLock?.();
});

// Prevent context menu on canvas (right-click reserved for boost)
canvas.addEventListener('contextmenu', (e)=> { e.preventDefault(); });

// Right mouse (button 2) for boost
canvas.addEventListener('mousedown', (e)=>{ if(e.button === 2){ input.boost = true; e.preventDefault(); } });

// Global mouse up handlers (catch even if pointer leaves canvas)
document.addEventListener('mouseup', (e)=>{ if(e.button === 2){ input.boost = false; } });

// Wheel zoom
canvas.addEventListener('wheel', (e)=>{
  if(document.pointerLockElement === canvas) return;
  cameraDistance += e.deltaY * 0.02;
  cameraDistance = Math.max(3, Math.min(80, cameraDistance));
  e.preventDefault();
}, {passive:false});

// Pointer lock change listener
document.addEventListener('pointerlockchange', ()=> {
  if(document.pointerLockElement === canvas) {
    document.addEventListener('mousemove', onPointerMove);
  } else {
    document.removeEventListener('mousemove', onPointerMove);
  }
});

// Accumulate pointer delta when locked
function onPointerMove(e){
  pointerDelta.x += e.movementX;
  pointerDelta.y += e.movementY;
}

// Fallback mouse position tracking (when pointer not locked)
let mouseNoLock = {x:0,y:0};
let prevMouseNoLock = {x:0,y:0};  // Track previous position to compute delta
window.addEventListener('mousemove', (ev)=>{
  if(document.pointerLockElement !== canvas){
    const newX = (ev.clientX / window.innerWidth) * 2 - 1;
    const newY = (ev.clientY / window.innerHeight) * 2 - 1;
    prevMouseNoLock.x = mouseNoLock.x;
    prevMouseNoLock.y = mouseNoLock.y;
    mouseNoLock.x = newX;
    mouseNoLock.y = newY;
  }
});

// ============================================================================
// DODGE LOGIC & HELPERS
// ============================================================================
// Trigger a dodge impulse with slipstream roll and centripetal force
function triggerDodge(side){
  const now = performance.now() / 1000;
  if(now - lastDodgeTime < DODGE_COOLDOWN) return;
  lastDodgeTime = now;
  
  const q = orientation.clone();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
  const forward = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
  let dir = (side === 'right') ? right.clone() : right.clone().negate();
  
  // 1. Primary Shove
  vel.add(dir.multiplyScalar(DODGE_IMPULSE));

  // 2. Centripetal Force (The Arc)
  const curveStrength = 0.025;
  const centripetalDir = new THREE.Vector3().crossVectors(vel, forward).normalize();
  if (side === 'right') centripetalDir.negate();
  vel.add(centripetalDir.multiplyScalar(vel.length() * curveStrength));

  // 3. Flat Spin Kick (Yaw Momentum)
  // Changed axis to Y (0, 1, 0) for a horizontal spin
  const spinForce = 1.0; 
  angularVelocityZ = (side === 'left') ? -spinForce : spinForce;
}


// ============================================================================
// HELPER: Look rotation quaternion
// ============================================================================
// Create a quaternion that points a local +Z forward and maintains local +Y as up
function lookRotation(forward, up){
  const z = forward.clone().normalize();
  const x = new THREE.Vector3().crossVectors(up, z).normalize();
  const y = new THREE.Vector3().crossVectors(z, x).normalize();
  const m = new THREE.Matrix4();
  m.makeBasis(x, y, z);
  const q = new THREE.Quaternion().setFromRotationMatrix(m);
  return q;
}

// ============================================================================
// UI ELEMENT REFERENCES & SLIDER HANDLERS (safe-guarded)
// ============================================================================
const fpsEl = document.getElementById('fps');
const speedEl = document.getElementById('speed');
const heightEl = document.getElementById('height');
const boostRange = document.getElementById('boostRange');
const dodgeRange = document.getElementById('dodgeRange');
const gravRange = document.getElementById('gravRange');
const tiltAccelRange = document.getElementById('tiltAccelRange');
const boostVal = document.getElementById('boostVal');
const dodgeVal = document.getElementById('dodgeVal');
const gravVal = document.getElementById('gravVal');
const tiltAccelVal = document.getElementById('tiltAccelVal');
const pitchSpeedRange = document.getElementById('pitchSpeedRange');
const rollSpeedRange = document.getElementById('rollSpeedRange');
const yawSpeedRange = document.getElementById('yawSpeedRange');
const pitchSpeedVal = document.getElementById('pitchSpeedVal');
const rollSpeedVal = document.getElementById('rollSpeedVal');
const yawSpeedVal = document.getElementById('yawSpeedVal');

// Update physics constants when sliders change
function updateBoost(v){ BOOST_ACCEL = Number(v); if(boostVal) boostVal.textContent = String(BOOST_ACCEL); }
function updateDodge(v){ DODGE_IMPULSE = Number(v); if(dodgeVal) dodgeVal.textContent = String(DODGE_IMPULSE); }
function updateGrav(v){ GRAVITY = Number(v); if(gravVal) gravVal.textContent = String(GRAVITY); }
function updateTiltAccel(v){ MAX_TILT_ACCELERATION = Number(v); if(tiltAccelVal) tiltAccelVal.textContent = String(MAX_TILT_ACCELERATION.toFixed(1)) + 'x'; }
function updatePitchSpeed(v){ PITCH_SPEED = Math.PI * Number(v); if(pitchSpeedVal) pitchSpeedVal.textContent = String(Number(v).toFixed(1)) + 'x'; }
function updateRollSpeed(v){ ROLL_SPEED = Math.PI * Number(v); if(rollSpeedVal) rollSpeedVal.textContent = String(Number(v).toFixed(1)) + 'x'; }
function updateYawSpeed(v){ MOUSE_SENS = Number(v); if(yawSpeedVal) yawSpeedVal.textContent = String(Number(v).toFixed(4)); }

// Attach slider listeners only if the elements exist (prevents throws when UI removed)
if(boostRange) boostRange.addEventListener('input', ()=> updateBoost(boostRange.value));
if(dodgeRange) dodgeRange.addEventListener('input', ()=> updateDodge(dodgeRange.value));
if(gravRange) gravRange.addEventListener('input', ()=> updateGrav(gravRange.value));
if(tiltAccelRange) tiltAccelRange.addEventListener('input', ()=> updateTiltAccel(tiltAccelRange.value));
if(pitchSpeedRange) pitchSpeedRange.addEventListener('input', ()=> updatePitchSpeed(pitchSpeedRange.value));
if(rollSpeedRange) rollSpeedRange.addEventListener('input', ()=> updateRollSpeed(rollSpeedRange.value));
if(yawSpeedRange) yawSpeedRange.addEventListener('input', ()=> updateYawSpeed(yawSpeedRange.value));

// ============================================================================
// MAIN ANIMATION LOOP
// ============================================================================
let lastT = performance.now()/1000;
let fpsTimer = performance.now();
let frameCount = 0;

function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()/1000;
  let dt = Math.min(0.033, t - lastT);  // Cap delta to 33ms to prevent huge jumps
  lastT = t;
  frameCount++;
  
  // Update FPS display every 0.5 seconds (only if element present)
  if(t - fpsTimer >= 0.5){
    if(fpsEl) fpsEl.textContent = Math.round((frameCount / (t - fpsTimer)));
    frameCount = 0; fpsTimer = t;
  }

// ========== GIMBAL ORIENTATION: Mouse position controls gimbal facing ==========
// ========== GIMBAL ORIENTATION: Locked until Pointer Lock ==========
  if (windowHasFocus && document.pointerLockElement === canvas) {
    if (Math.abs(pointerDelta.x) > 0.0001) {
      const yaw = -pointerDelta.x * MOUSE_SENS;
      const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
      window.gimbalOrientation.premultiply(qYaw);
      pointerDelta.x = 0;
    }
    pointerDelta.y = 0;
  }
  // No "else" block means the camera orientation remains static if not locked
  window.gimbalOrientation.normalize();
  // ELSE: If window is blurred (tabbed out), we do nothing. 
  // window.gimbalOrientation stays at its last value, freezing the camera.

  window.gimbalOrientation.normalize();

// ========== SPARROW SPIN PHYSICS (Flat Spin) ==========
  if (Math.abs(angularVelocityZ) > 0.01) {
    // Changed axis from Z (0,0,1) to Y (0,1,0)
    const frameSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angularVelocityZ * dt);
    orientation.multiply(frameSpin);
    
    // Friction: slowing the spin down
    angularVelocityZ *= 0.92; 
  }

  const distFromGround = pos.y - 0.0;
  const isDestabilizing = destabilizers || (destReleasedAt && (t - destReleasedAt < PHYS.shiftGracePeriod));

  if(!windowHasFocus) {
    window.sparrowFollowOrientation.copy(orientation);
  } else if(isDestabilizing) {
    // Destabilizer Manual Tilt logic remains here...
    window.sparrowFollowOrientation.copy(orientation);
  } else {
    if(distFromGround < 1.2) {
      // Near ground: Keep auto-leveling active
      window.sparrowFollowOrientation.slerp(window.gimbalOrientation, 0.01);
      orientation.copy(window.sparrowFollowOrientation);
    } else {
      // IN AIR: Only follow Camera Yaw (Left/Right)
      const gEuler = new THREE.Euler().setFromQuaternion(window.gimbalOrientation, 'YXZ');
      const yawOnly = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, gEuler.y, 0, 'YXZ'));
      
      // Use a very weak slerp (0.0005) so the nose points forward 
      // but doesn't force the sparrow to "snap" level
      orientation.slerp(yawOnly, 0.0005);
    }
  }

  // ========== DESTABILIZER CONTROLS (pitch and roll on sparrow for slipstreaming) ==========
  if(isDestabilizing){
    // Update text color to indicate active grace period
    destText.textContent = 'ON';
    destText.style.color = '#ff3d3d';

    // WASD applies pitch/roll directly to sparrow when destabilizers active
    let pitchInput = 0;
    if(input.tiltF) pitchInput += 1;  // W = pitch up
    if(input.tiltB) pitchInput -= 1;  // S = pitch down
    let rollInput = 0;
    if(input.tiltL) rollInput += 1;   // A = roll left
    if(input.tiltR) rollInput -= 1;   // D = roll right
    
    // Update hold times for acceleration effect
    if(Math.abs(pitchInput) > 0.001){
      // Accumulate hold time based on which pitch input is active
      if(input.tiltF) tiltInputHoldTimes.tiltF += dt;
      if(input.tiltB) tiltInputHoldTimes.tiltB += dt;
    } else {
      tiltInputHoldTimes.tiltF = 0;
      tiltInputHoldTimes.tiltB = 0;
    }
    
    if(Math.abs(rollInput) > 0.001){
      // Accumulate hold time based on which roll input is active
      if(input.tiltL) tiltInputHoldTimes.tiltL += dt;
      if(input.tiltR) tiltInputHoldTimes.tiltR += dt;
    } else {
      tiltInputHoldTimes.tiltL = 0;
      tiltInputHoldTimes.tiltR = 0;
    }
    
    // Calculate acceleration multiplier based on hold time (0.5 sec to reach full speed)
    // Starts at MAX_TILT_ACCELERATION, ramps up to 1.0x over 0.5 seconds
    const pitchHoldTime = Math.max(tiltInputHoldTimes.tiltF, tiltInputHoldTimes.tiltB);
    const pitchAccel = MAX_TILT_ACCELERATION + (Math.min(pitchHoldTime / 0.5, 1.0) * (1.0 - MAX_TILT_ACCELERATION));
    
    const rollHoldTime = Math.max(tiltInputHoldTimes.tiltL, tiltInputHoldTimes.tiltR);
    const rollAccel = MAX_TILT_ACCELERATION + (Math.min(rollHoldTime / 0.5, 1.0) * (1.0 - MAX_TILT_ACCELERATION));
    
    // Pitch around world X axis (W/S) - applied to sparrow only
    if(Math.abs(pitchInput) > 0.001){
      const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchInput * PITCH_SPEED * pitchAccel * dt);
      orientation.multiply(qPitch);
    }
    
    // Roll around world Z axis (A/D) - applied to sparrow only
    if(Math.abs(rollInput) > 0.001){
      const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), rollInput * ROLL_SPEED * rollAccel * dt);
      orientation.multiply(qRoll);
    }
  } else {
    destText.textContent = 'OFF';
    destText.style.color = '';
  }

  // ========== PHYSICS: Forces and velocity update ==========
  const localForward = new THREE.Vector3(0,0,1).applyQuaternion(orientation).normalize();
  const localRight = new THREE.Vector3(1,0,0).applyQuaternion(orientation).normalize();
  const localUp = new THREE.Vector3(0,1,0).applyQuaternion(orientation).normalize();

  // Boost (right-click): forward acceleration
  if(input.boost){
    vel.add(localForward.clone().multiplyScalar(BOOST_ACCEL * dt));
  }

  // Compute camera-relative directions for WASD movement
  const camForward = new THREE.Vector3();
  camera.getWorldDirection(camForward);
  camForward.y = 0;
  if(camForward.lengthSq() < 1e-6) camForward.set(0,0,1);
  camForward.normalize();
  const camRight = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camForward).normalize();

  // Horizontal movement (when destabilizers OFF)
// Horizontal movement (ONLY when destabilizers are NOT active)
  if(!isDestabilizing){
    let horizAccelForce = new THREE.Vector3(0,0,0);
    if(input.moveF) horizAccelForce.add(camForward);
    if(input.moveB) horizAccelForce.add(camForward.clone().negate());
    if(input.moveR) horizAccelForce.add(camRight);
    if(input.moveL) horizAccelForce.add(camRight.clone().negate());
    
    if(horizAccelForce.lengthSq() > 0.0001){
      horizAccelForce.normalize();
      horizAccelForce.multiplyScalar(HORIZONTAL_ACCEL * dt);
      vel.add(horizAccelForce);
    }
  } else {
    // When destabilizing, we skip the horizAccelForce block entirely,
    // effectively "swapping" the key function to Tilt/Spin logic.
  }

  // Up-thrust (Space)
  if(input.upThrust){
    vel.y += UP_THRUST * dt;
  }

  // Gravity
  vel.y -= GRAVITY * dt;

  // Air drag/resistance
  vel.multiplyScalar(1.0 - Math.min(0.16, AIR_DRAG * dt * 0.08));

  // Speed limiter
  if(vel.length() > MAX_SPEED) vel.setLength(MAX_SPEED);

  // Integrate position
  pos.addScaledVector(vel, dt);

  // ========== GROUND ALIGNMENT (when near floor) ==========
  // Aligns gimbal orientation parallel to ground while preserving forward direction
  const groundY = 0.0;
  const dist = pos.y - groundY;
  if(dist < GROUND_ALIGN_DIST){
    // Compute forward projected onto ground plane
    const forwardVec = new THREE.Vector3(0,0,1).applyQuaternion(window.gimbalOrientation).clone();
    forwardVec.y = 0;  // Project to XZ plane
    if(forwardVec.lengthSq() < 1e-6) forwardVec.set(0,0,1);
    forwardVec.normalize();
    // Build target quaternion with ground-up normal
    const targetQ = lookRotation(forwardVec, new THREE.Vector3(0,1,0));
    window.gimbalOrientation.slerp(targetQ, GROUND_ALIGN_SLERP);
    // Friction with ground: slow downward velocity and clamp below ground
    if(pos.y < 1.0){
      pos.y = 1.0;
      if(vel.y < -0.5) vel.y = Math.max(-0.5, -vel.y * 0.08);
    }
  }

  // Apply updated physics to mesh
  sparrow.position.copy(pos);
  sparrow.quaternion.copy(orientation);

  // ========== GIMBAL POSITIONING ==========
  // Gimbal sphere orbits around sparrow position, staying ahead in the gimbal's facing direction
  const gimbalDistanceOffset = -1;  // How far ahead the gimbal sphere floats
  const gimbalForwardVec = new THREE.Vector3(0,0,1).applyQuaternion(window.gimbalOrientation).normalize();
  const gimbalOffset = gimbalForwardVec.clone().multiplyScalar(gimbalDistanceOffset);
  gimbalOffset.y = 1;  // Gimbal sits on top of sparrow
  window.gimbalSphere.position.copy(pos).add(gimbalOffset);  
  
  // Store current position for next frame's velocity calculation
  prevPos.copy(pos);
  // ========== CAMERA FOLLOW GIMBAL ==========
  // Camera position stays behind gimbal sphere and faces its direction
  const gimbalPos = window.gimbalSphere.position;
  
  // Position camera behind the gimbal, offset backwards from its facing direction
  const followDistance = 15;  // Distance behind the sphere
  const cameraOffset = gimbalForwardVec.clone().multiplyScalar(-followDistance);
  cameraOffset.y += 3;  // Slightly above the sphere
  camera.position.copy(gimbalPos).add(cameraOffset);
  
  // Camera looks in the same direction the sphere is facing (far ahead point)
  const cameraLookTarget = gimbalPos.clone().addScaledVector(gimbalForwardVec, 100);
  
  // Point camera forward
  camera.lookAt(cameraLookTarget);
  
  // Ensure camera up is world up
  camera.up.set(0, 1, 0);
  
  // Prevent camera from clipping into the ground
  const minCameraHeight = 0.5;
  if(camera.position.y < groundY + minCameraHeight){
    camera.position.y = groundY + minCameraHeight;
  }

  // Update UI displays
  speedEl.textContent = vel.length().toFixed(1);
  heightEl.textContent = pos.y.toFixed(1);
  
  // Update position and facing direction for debugging
  document.getElementById('posX').textContent = pos.x.toFixed(2);
  document.getElementById('posY').textContent = pos.y.toFixed(2);
  document.getElementById('posZ').textContent = pos.z.toFixed(2);
  const facingVector = new THREE.Vector3(0, 0, 1).applyQuaternion(orientation).normalize();
  document.getElementById('facingDir').textContent = `${facingVector.x.toFixed(2)}, ${facingVector.y.toFixed(2)}, ${facingVector.z.toFixed(2)}`;
  renderer.render(scene, camera);
}

// ============================================================================
// INITIALIZATION & STARTUP
// ============================================================================
// Initialize sliders from current tuning values
document.getElementById('boostRange').value = BOOST_ACCEL;
document.getElementById('dodgeRange').value = DODGE_IMPULSE;
document.getElementById('gravRange').value = GRAVITY;
// Update display readouts
if(typeof updateBoost === 'function') updateBoost(BOOST_ACCEL);
if(typeof updateDodge === 'function') updateDodge(DODGE_IMPULSE);
if(typeof updateGrav === 'function') updateGrav(GRAVITY);

// Start main loop
animate();
console.log('animate started'); if(statusInit) statusInit.textContent = 'Model: running';

// Window resize handler
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

// Startup info logged to console
console.log("set :)");
</script>
<script>
// ============================================================================
// MODEL TRANSFORM CONTROLS (live rotation, scale, position)
// ============================================================================
// UI elements for adjusting loaded model transform
const ui = {
  rotYaw: document.getElementById('rotYaw'), rotPitch: document.getElementById('rotPitch'), rotRoll: document.getElementById('rotRoll'),
  rotYawVal: document.getElementById('rotYawVal'), rotPitchVal: document.getElementById('rotPitchVal'), rotRollVal: document.getElementById('rotRollVal'),
  scaleSlider: document.getElementById('scaleSlider'), scaleVal: document.getElementById('scaleVal'),
  posX: document.getElementById('modelPosX'), posY: document.getElementById('modelPosY'), posZ: document.getElementById('modelPosZ'),
  posXVal: document.getElementById('modelPosXVal'), posYVal: document.getElementById('modelPosYVal'), posZVal: document.getElementById('modelPosZVal'),
};

function deg(v){ return v * Math.PI / 180; }
function rad(v){ return v / Math.PI * 180; }

// Apply transform values from sliders to the currently-loaded model
function safeApplyTransform(){
  const m = window.lastLoadedModel; if(!m) return;
  const y = deg(Number(ui.rotYaw.value || 0));
  const x = deg(Number(ui.rotPitch.value || 0));
  const z = deg(Number(ui.rotRoll.value || 0));
  m.rotation.set(x, y, z);
  const s = Number(ui.scaleSlider.value) || 1;
  m.scale.set(s, s, s);
  const px = Number(ui.posX.value) || 0;
  const py = Number(ui.posY.value) || 0;
  const pz = Number(ui.posZ.value) || 0;
  m.position.set(px, py, pz);
  if(ui.rotYawVal) ui.rotYawVal.textContent = ui.rotYaw.value + '°';
  if(ui.rotPitchVal) ui.rotPitchVal.textContent = ui.rotPitch.value + '°';
  if(ui.rotRollVal) ui.rotRollVal.textContent = ui.rotRoll.value + '°';
  if(ui.scaleVal) ui.scaleVal.textContent = Number(ui.scaleSlider.value).toFixed(2) + 'x';
  if(ui.posXVal) ui.posXVal.textContent = Number(ui.posX.value).toFixed(2);
  if(ui.posYVal) ui.posYVal.textContent = Number(ui.posY.value).toFixed(2);
  if(ui.posZVal) ui.posZVal.textContent = Number(ui.posZ.value).toFixed(2);
}

// Initialize sliders from a loaded model's current transform
function tryInitControlsFromModel(m){
  if(!m) return;
  const rx = m.rotation.x || 0, ry = m.rotation.y || 0, rz = m.rotation.z || 0;
  if(ui.rotYaw) ui.rotYaw.value = Math.round(rad(ry));
  if(ui.rotPitch) ui.rotPitch.value = Math.round(rad(rx));
  if(ui.rotRoll) ui.rotRoll.value = Math.round(rad(rz));
  const s = (m.scale && m.scale.x) ? m.scale.x : 1;
  if(ui.scaleSlider) ui.scaleSlider.value = Number(s).toFixed(2);
  if(ui.posX) ui.posX.value = (m.position && m.position.x) ? m.position.x : 0;
  if(ui.posY) ui.posY.value = (m.position && m.position.y) ? m.position.y : 0;
  if(ui.posZ) ui.posZ.value = (m.position && m.position.z) ? m.position.z : 0;
  safeApplyTransform();
}

// Apply a default transform preset to loaded model
function applyDefaultPreset(){
  if(ui.rotYaw) ui.rotYaw.value = '-0';
  if(ui.rotPitch) ui.rotPitch.value = '-90';
  if(ui.rotRoll) ui.rotRoll.value = '-90';
  if(ui.scaleSlider) ui.scaleSlider.value = '0.08';
  if(ui.posX) ui.posX.value = '0.4';
  if(ui.posY) ui.posY.value = '-1.0';
  if(ui.posZ) ui.posZ.value = '1.5';
  safeApplyTransform();
}

// Capture the loaded model's local basis (forward/up/right) for control mapping
function captureModelBasis(m){
  try{
    if(!m) return;
    const q = new THREE.Quaternion();
    m.getWorldQuaternion(q);
    const forward = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
    const up = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();
    const right = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
    window.modelBasis = { forward, up, right };
    console.log('Model basis captured:', window.modelBasis);
  }catch(e){ console.warn('captureModelBasis failed', e); }
}

// Wire up input handlers for transform sliders
[ui.rotYaw, ui.rotPitch, ui.rotRoll, ui.scaleSlider, ui.posX, ui.posY, ui.posZ].forEach(el=>{ if(el) el.addEventListener('input', safeApplyTransform); });

// Reset transform button: return sliders to defaults
if(ui.resetBtn) ui.resetBtn.addEventListener('click', ()=>{
  if(ui.rotYaw) ui.rotYaw.value = '0'; if(ui.rotPitch) ui.rotPitch.value = '0'; if(ui.rotRoll) ui.rotRoll.value = '0';
  if(ui.scaleSlider) ui.scaleSlider.value = '1'; if(ui.posX) ui.posX.value='0'; if(ui.posY) ui.posY.value='0'; if(ui.posZ) ui.posZ.value='0';
  safeApplyTransform();
});
</script>
</body>
</html>
